
1- Send AsynchronousRequest

[NSURLConnection sendAsynchronousRequest:[[NSURLRequest alloc] initWithURL:url] queue:[[NSOperationQueue alloc] init] completionHandler:^(NSURLResponse *response, NSData *data, NSError *error) {
        
        if (error) {
            [self.delegate fetchingGroupsFailedWithError:error];
        } else {
            [self.delegate receivedGroupsJSON:data];
        }
    }];
    
Description : Send AsynchronousRequest



2- performSelector With Object data passing 

NSArray * arrayOfThingsIWantToPassAlong = 
    [NSArray arrayWithObjects: @"first", @"second", nil];

[self performSelector:@selector(fooFirstInput:) 
           withObject:arrayOfThingsIWantToPassAlong  
           afterDelay:15.0];
           
Descriptions :
You need to encapsulate the data you want to send along into some single Objective C object (e.g. a NSArray, a NSDictionary, some custom Objective C type) 
and then pass it through the[NSObject performSelector:withObject:afterDelay:] method that is well known and loved.

3 - respondsToSelector
if ([self.delegate respondsToSelector:@selector(engineDidStartRunning:)]) {
        [self.delegate engineDidStartRunning:self];
    }
    
Description : 
You use it pretty much just when you think you need to: to check to see if an object implements the method you are about to call. Usually this is done when you have an optional methods or an informal protocol.

I've only ever used respondsToSelector when I'm writing code that must communicate with a delegate object.


4- Hide Tab Bar 
       destViewController.hidesBottomBarWhenPushed = YES;
Description : 
Hide the tab bar when move to next view controller 

Example: - (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {
    if ([segue.identifier isEqualToString:@"showRecipeDetail"]) {
        NSIndexPath *indexPath = [self.tableView indexPathForSelectedRow];
        RecipeDetailViewController *destViewController = segue.destinationViewController;
        destViewController.recipeName = [recipes objectAtIndex:indexPath.row];

        // Hide bottom tab bar in the detail view
        destViewController.hidesBottomBarWhenPushed = YES;
    }
}

5- Table View With Return Case:

- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    return self.dataSource ? 1 : 0;
}
 
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return self.dataSource ? self.dataSource.count : 0;
}
 
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    TPSButtonCell *cell = (TPSButtonCell *)[tableView dequeueReusableCellWithIdentifier:CellIdentifier forIndexPath:indexPath];
 
    // Fetch Item
    NSDictionary *item = [self.dataSource objectAtIndex:indexPath.row];
 
    // Configure Table View Cell
    [cell.titleLabel setText:[NSString stringWithFormat:@"%@ (%@)", item[@"title"], item[@"year"]]];
    [cell.actionButton addTarget:self action:@selector(didTapButton:) forControlEvents:UIControlEventTouchUpInside];
 
    return cell;
}

Description : Return TRUE OR FALSE DATA Results 

6- Objective-C Blocks......

1- They can be executed in a later time, and not when the code of the scope they have been implemented is being executed.
2- Their usage leads eventually to a much cleaner and tidier code writing, as they can be used instead of delegate methods, written just in one place and not spread to many files.

 Blocks are objects, so they can be stored to NSArray or NSDictionary data structures, as well as to be returned from methods, even to be assigned to variables.
ReturnType (^blockName)(Parameters)
int (^firstBlock)(NSString *param1, int param2);
void (^showName)(NSString *myName);

NSDate *(^whatDayIsIt)(void);

void (^allVoid)(void);

NSString *(^composeName)(NSString *firstName, NSString *lastName);

 int (^howMany)(int, int) = ^(int a, int b){
return a + b;
};

 void (^justAMessage)(NSString *) = ^(NSString *message){
NSLog(@"%@", message);
};

 // Declare a block variable.
void (^xyz)(void);

// Some other code...

// Define the block.
xyz = ^(void){
NSLog(@"What's up, Doc?");
};

@interface ViewController ()
@property (nonatomic, strong) NSString *(^blockAsAMemberVar)(void);


 _blockAsAMemberVar = ^(void){
return @"This block is declared as a member variable!";
};
float results = ^(float value1, float value2, float value3){
        return value1 * value2 * value3;
    } (1.2, 3.4, 5.6);

    NSLog(@"%f", results);

    // Output: 22.848001
    
- Variable with start name __ ( __block) are mutable . else by dafult all variables are read only.

One important notice before moving forward is that you should never forget that the completion handler should always be the last parameter in a method. A method can have as many arguments as you want, but always have the completion handler as the last argument in the parameters list.
----------
 [self presentViewController:viewController animated:YES completion:^{
        NSLog(@"View Controller was presented...");
        
        // Other code related to view controller presentation...
    }];
--------------
[UIView animateWithDuration:0.5
                     animations:^{
                         // Animation-related code here...
                         [self.view setAlpha:0.5];
                     }
                     completion:^(BOOL finished) {
                         // Any completion handler related code here...
                         
                         NSLog(@"Animation is over.");
                     }];
-------------
-(void)addNumber:(int)number1 withNumber:(int)number2 andCompletionHandler:(void (^)(int result))completionHandler{
    int result = number1 + number2;
    completionHandler(result);
}
----------
- (void)viewDidLoad
{
    ...

    [self addNumber:5 withNumber:7 andCompletionHandler:^(int result) {
        // We just log the result, no need to do anything else.
        NSLog(@"The result is %d", result);
    }];
}
A completion handler is the way (technique) for implementing callback functionality using blocks.

